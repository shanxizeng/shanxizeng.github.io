<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>编译原理-Aho-1</title>
      <link href="/2022/06/30/compilers_principles_aho_1/"/>
      <url>/2022/06/30/compilers_principles_aho_1/</url>
      
        <content type="html"><![CDATA[<p>编译器(compiler)就是将用一种语言编写的程序转化为等价的用目标语言编写的程序的一个程序。解释器(interpreter)是另一种常见的语言处理器，并不通过翻译的方式生成目标程序，而是直接利用用户提供的输入执行源程序中指定的操作。编译器生成的程序通常要比解释器快很多，但解释器的错误诊断效果通常比编译器更好。</p><p>一个源程序可能被分割为多个部分，并存放在独立的文件中。把源程序聚合在一起的任务由预处理器(preprocessor)独立完成。</p><p>将经过预处理器处理的程序作为输入传递给一个编译器，一般由编译器转为一个汇编语言程序作为输出，并由汇编器(assembler)处理生成可重定位的机器代码。</p><p>在大型的程序中，可重定位的机器代码通常要和其他的可重定位目标文件以及库文件连接在一起，形成真正运行的代码。外部内存地址的问题由链接器(linker)解决，最后加载器(loader)把所有可执行文件放到内存中执行。</p><h2 id="编译器的结构"><a href="#编译器的结构" class="headerlink" title="编译器的结构"></a>编译器的结构</h2><p>编译器将源程序映射为语义上等价的目标程序。映射的过程分为两个方面：分析(analysis)和综合(synthesis)。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>通常来说，编译的第一个步骤称为词法分析(lexical analysis)或扫描(scanning)。词法分析器读入源程序，将它们组成为有意义的词素(lexeme)序列。每个词素由一个词法单元(token)<code>&lt;token-name, attribute-value&gt;</code>构成。token-name是下一个步骤中要用到的符号，attribute-value是与符号表相关的信息。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>编译的第二个步骤称为语法分析(syntax analysis)或解析(parsing)。语法分析器利用词法分析器得到的词法单元的第一个分量创建树形的中间表示，如语法树(syntax tree)。给出了词法分析器产生的词法单元流的语法结构。</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语义分析器(semantic analysis)使用语法树和符号表中的信息来检查程序是否和语言定义的语义一致，并将这些信息存放在语法树或符号表中。同时收集类型信息，进行类型检查(type checking)。</p><h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>在语法分析和语义分析完成后，编译器一般会生成一个明确的低级的或类机器语言的中间表示。可以将这个中间表示看作在一个虚拟的机器上执行的程序。这个中间表示一般要满足易于生成并能较为轻松地翻译为目标语言。</p><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>机器无关的代码优化通过改进中间代码，以期望生成更好的目标代码。此外还有机器相关的优化。</p><p>代码优化必须满足下面的设计目标：</p><ol><li><p>优化必须是正确的，不能改变被编译程序的含义。</p></li><li><p>优化必须能够改善很多程序的性能。</p></li><li><p>优化需要的时间必须保持在合理的区间内。</p></li><li><p>所需要的工程方面的工作必须是可管理的。</p></li></ol><h3 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h3><p>代码生成器以中间形式作为输入，映射到目标语言。如果目标语言是机器语言，那么就要为每个变量选择寄存器或内存地址。代码生成的一个至关重要的方面是合理分配寄存器以存放变量的值。</p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>编译器在编译的过程中要记录源程序中使用的变量和过程的各种属性。这些由符号表来完成。</p><p>以上中的若干个步骤进行组合称为一趟(pass)。</p><h2 id="程序设计语言"><a href="#程序设计语言" class="headerlink" title="程序设计语言"></a>程序设计语言</h2><p>分类方式：</p><p>按代际来划分：第一代：机器语言；第二代：汇编语言；第三代：Fortran,Cobol,Lisp,C,C++,Java等高级语言；第四代是为特定应用设计的语言如用于生成报告的NOMAD，用于数据库查询的SQL等；第五代指基于逻辑和约束的语言，如Prolog和OPS5。</p><p>将程序中指明如何完成一个计算任务的语言称为强制式(imperative)语言，如C,C++,Java等；将程序中指明要进行哪些计算任务的语言称为声明式(declarative)语言，如Haskell,Prolog等。</p><p>冯·诺依曼语言(von Neumann language)是指以冯·诺伊曼计算机体系结构为计算模型的语言。</p><p>面向对象语言(object-oriented language)指的是支持面向对象编程的语言。</p><p>脚本语言(scripting language)是具有高层次运算符的解释型语言。</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语义学简介</title>
      <link href="/2022/06/29/formal_semantics/"/>
      <url>/2022/06/29/formal_semantics/</url>
      
        <content type="html"><![CDATA[<p>如果要描述一个语言，我们需要描述三个方面的内容：字符集(alphabet)、语法(syntax)、语义(semantics)。对于一个程序设计语言来说也是如此。</p><p>语言的语法决定了我们能够写出来怎样的程序，而语义则决定了不同程序执行的具体的效果。</p><p>在写程序的时候，我们往往比较关注语言的语法，以写出能够被接受的程序。但同时，语言的语义也相当重要。有了恰当定义的语义，我们才能对程序运行的行为进行准确的描述，给定解释程序的标准，同时这也是进行程序分析的基础。</p><p>实际上，说明一个程序的正确性要比写出这个程序困难的多，一个正确定义的语义是保证程序正确性的重要条件。</p><h3 id="内存-State"><a href="#内存-State" class="headerlink" title="内存(State)"></a>内存(State)</h3><p>程序在运行的时候，必然要涉及内存的状态，及变量的值等。要描述程序运行的行为，就必须要对计算机的内存状态给出定义。</p><p>我们将内存抽象为一个从变量到值的映射，定义为一个状态(State)，如$(x\mapsto a;y\mapsto b;z\mapsto c)$。状态会随着程序的运行而发生变化。而语义就是描述了一个程序将一个状态转移到了另一个状态。</p><p>下面考虑一个简单的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z := x;</span><br><span class="line">x := y;</span><br><span class="line">y := z;</span><br></pre></td></tr></table></figure><h3 id="操作语义-Operational-Semantics"><a href="#操作语义-Operational-Semantics" class="headerlink" title="操作语义(Operational Semantics)"></a>操作语义(Operational Semantics)</h3><p>操作语义将一个程序执行的行为解释为初始状态经过一个程序后得到一个最终状态。</p><p>比如在$st=(x\mapsto a;y\mapsto b;z\mapsto c)$上运行程序<code>z := x; x := y; y := z</code>。</p><p>这里我们会用到两条推导规则：</p><script type="math/tex; mode=display">\begin{array}{c}    st\ a = n\\\hline    st =[x := a]\Rightarrow (x\mapsto n; st)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    st =[c_1]\Rightarrow st'\ \ \ st' =[c_2]\Rightarrow st''\\\hline    st =[c_1;c_2]\Rightarrow st''\end{array}</script><p>有了这两条推导规则，我们可以得到，</p><script type="math/tex; mode=display">\begin{array}{c}    (x\mapsto a;y\mapsto b;z\mapsto c)\ x = a\\\hline    (x\mapsto a;y\mapsto b;z\mapsto c) =[z := x]\Rightarrow (x\mapsto a;y\mapsto b;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    (x\mapsto a;y\mapsto b;z\mapsto c)\ y = b\\\hline    (x\mapsto a;y\mapsto b;z\mapsto a) =[x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}        (x\mapsto a;y\mapsto b;z\mapsto c) =[z := x]\Rightarrow (x\mapsto a;y\mapsto b;z\mapsto a)\\        (x\mapsto a;y\mapsto b;z\mapsto a) =[x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)    \\\hline    (x\mapsto a;y\mapsto b;z\mapsto c) =[z := x; x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}        (x\mapsto b;y\mapsto b;z\mapsto a)\ z = a    \\\hline    (x\mapsto b;y\mapsto b;z\mapsto a) =[y := z]\Rightarrow (x\mapsto b;y\mapsto a;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}(x\mapsto a;y\mapsto b;z\mapsto c) =[z := x; x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)\\    (x\mapsto b;y\mapsto b;z\mapsto a) =[y := z]\Rightarrow (x\mapsto b;y\mapsto a;z\mapsto a)\\\hline(x\mapsto a;y\mapsto b;z\mapsto c) =[z := x; x := y; y := z]\Rightarrow  (x\mapsto b;y\mapsto a;z\mapsto a)\end{array}</script><p>证明了程序的正确性。</p><h3 id="指称语义-Denotational-Semantics"><a href="#指称语义-Denotational-Semantics" class="headerlink" title="指称语义(Denotational Semantics)"></a>指称语义(Denotational Semantics)</h3><p>指称语义将程序抽象为一个数学上的函数。比如，要描述程序对状态的影响，我们可以把程序看作$State\to State$的函数。</p><p>比如在$st=(x\mapsto a;y\mapsto b;z\mapsto c)$上运行程序<code>z := x; x := y; y := z</code>。</p><p>这里我们会用到两条推导规则：</p><script type="math/tex; mode=display">[\![ s_1; s_2 ]\!] = [\![ s_2 ]\!]\circ [\![s_1]\!]</script><script type="math/tex; mode=display">([\![ x := v]\!]\ st)\ y = \left\{\begin{array}{ll}st\ y& ,y\not =x\\v& ,otherwise\end{array}\right.</script><p>由此，我们可以得到，</p><script type="math/tex; mode=display">\begin{array}{rcl}    [\![z := x; x := y; y := z]\!](x\mapsto a;y\mapsto b;z\mapsto c)&=&\\    [\![ y := z]\!]\circ [\![x := y]\!]\circ[\![z := x]\!](x\mapsto a;y\mapsto b;z\mapsto c)&=&\\    [\![ y := z]\!]\circ [\![x := y]\!](x\mapsto a;y\mapsto b;z\mapsto a)&=&\\    [\![ y := z]\!](x\mapsto b;y\mapsto b;z\mapsto a)&=&(x\mapsto b;y\mapsto a;z\mapsto a)\\\end{array}</script><p>不难发现，操作语义和指称语义的原理是几乎相同的，区别只在于描述不同。</p><h3 id="公理语义-Axiomatic-Semantics"><a href="#公理语义-Axiomatic-Semantics" class="headerlink" title="公理语义(Axiomatic Semantics)"></a>公理语义(Axiomatic Semantics)</h3><p>公理语义更关注程序的性质，通过一系列的公理推出程序在某些状态上符合的某个定理。</p><p>如一个最著名的实例，霍尔逻辑(Hoare Logic)。霍尔逻辑由霍尔三元组来描述，其由三个部分即前条件(pre-condition)、程序和后条件(post-condition)组成。其含义为程序在满足前条件的状态上运行得到的状态满足后条件。如$\{P\}c\{Q\}$</p><p>比如在$st=(x\mapsto a;y\mapsto b;z\mapsto c)$上运行程序<code>z := x; x := y; y := z</code>。</p><p>这里我们会用到两条推导规则：</p><script type="math/tex; mode=display">\begin{array}{c}    \{P\}c_1\{Q\}\ \ \ \{Q\}c_2\{R\}\\\hline    \{P\}c_1;c_2\{R\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{P[a/x]\}x:=a\{R\}\end{array}</script><p>其中$P[a/x]$指使用a替换P中的所有x，如$\{Y = 2\} X := Y \{X = 2\}$</p><p>通过上面两条规则，我们可以得到</p><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{x=a\land y=b\}z := x\{y=b\land z=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{y=b\land z=a\}x := y\{x=b\land z=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \{x=a\land y=b\}z := x\{y=b\land z=a\}\ \ \ \{y=b\land z=a\}x := y\{x=b\land z=a\}\\\hline    \{x=a\land y=b\}z := x; x := y\{x=b\land z=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{x=b\land z=a\}y := z\{x=b\land y=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \{x=a\land y=b\}z := x; x := y\{x=b\land z=a\}\ \ \ \{x=b\land z=a\}y := z\{x=b\land y=a\}\\\hline    \{x=a\land y=b\}z := x; x := y; y := z\{x=b\land y=a\}\end{array}</script><p>证明了程序关于交换的一个性质。</p>]]></content>
      
      
      <categories>
          
          <category> 形式语义 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 形式语义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/06/27/test/"/>
      <url>/2022/06/27/test/</url>
      
        <content type="html"><![CDATA[<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn=<span class="number">110000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> to[Maxn],nxt[Maxn],first[Maxn],tot=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    to[tot]=v;</span><br><span class="line">    nxt[tot]=first[u];</span><br><span class="line">    first[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\sum_{i=1}^n i^2=\frac{n(n+1)(2n+1)}{6}</script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
