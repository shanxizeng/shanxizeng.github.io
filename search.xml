<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>datalog简易教程</title>
      <link href="/2022/07/08/datalog/"/>
      <url>/2022/07/08/datalog/</url>
      
        <content type="html"><![CDATA[<h2 id="DataLog"><a href="#DataLog" class="headerlink" title="DataLog"></a>DataLog</h2><p><a href="https://github.com/shanxizeng/datalog_test">github地址</a></p><h3 id="Souffle"><a href="#Souffle" class="headerlink" title="Souffle"></a><a href="https://github.com/souffle-lang/souffle">Souffle</a></h3><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>datalog是prolog的一个子集，主要表达数据及其关系。</p><p>Datalog 是一种（声明式）基于逻辑的查询语言，允许用户执行递归查询。Datalog 语法的规范没有统一的标准，通常采用 Prolog 风格的语法。Soufflé 的语法受到 Datalog 实现的启发，即 Z3 中的 bddbddb(BDD-Based Deductive DataBase) 和 muZ。</p><p>Soufflé 为大规模面向逻辑的编程提供了软件工程功能（例如组件），对于实际使用，Soufflé 通过算术函子（arithmetic functors）扩展了 Datalog 使其图灵等价，让程序员能够编写非终止的程序。</p><p>Soufflé 中的主要语言元素是关系声明（relation declarations）、事实（facts）、规则（rules）和指令（directives）。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>datalog中有两种基本类型：symbol和number。其中symbol包含了所有的字符串，而number中包含了所有的整数。datalog内部使用序数表示字符串，<code>ord(str)</code>表示其序数。</p><p>souffle中另外还有两种类型：float和unsigned。其中float包含了浮点数，unsigned包含了无符号整数。</p><p>souffle中支持各种基本代数运算（包括取余和取幂）以及位运算和逻辑运算（同C语言一样，1为true，0为false）。同时还有 autoinc()运算。autoinc()每次使用时产生一个新的值（从零开始）。autoinc不能在递归关系中使用。（参考autoincTest.dl）</p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>souffle中的关系必须声明。关系由一个列表<code>(x1,x2,...,xk)</code>组成。每个部分声明各自的类型。</p><p>使用<code>.decl &lt;rel-name&gt;(x1:type1, x2:type2, ..., xk:typek)</code>定义关系。</p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>使用<code>.input &lt;rel-name&gt;</code>和<code>.output &lt;rel-name&gt;</code>进行输入输出。从<code>&lt;rel-name&gt;.facts</code>中读取输入，并将输出存在<code>&lt;rel-name&gt;.csv</code>中。注意数据要用制表符分隔。</p><p>使用<code>.printsize &lt;rel-name&gt;</code>输出集合基数。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>规则是条件逻辑语句，由规则头和规则体组成。如<code>path(x,y) :- path(x,z),edge(z,y)</code></p><p>使用$!$对某个语句取非。注意为了保证单调性，在循环的定义中不能使用not。</p><h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>Soufflé 中的聚合是指使用特定的函子来汇总有关查询的信息，聚合类型包括计数、求最小值/最大值、求和。在 Soufflé 中，信息通常不能从子目标（聚合函子的参数）流到外部作用域。例如，如果希望找到关系 Cost(x) 的最小值，无法找到使成本最小化的特定 x 值，因为这样的 x 值可能不是唯一的。</p><p>计数：<code>count:&#123;&lt;sub-goal&gt;&#125;</code></p><p>最小：<code>max &lt;var&gt;:&#123;&lt;sub-goal(&lt;var&gt;)&gt;&#125;</code></p><p>最大：<code>min &lt;var&gt;:&#123;&lt;sub-goal(&lt;var&gt;)&gt;&#125;</code></p><p>求和：<code>sum &lt;var&gt;:&#123;&lt;sub-goal(&lt;var&gt;)&gt;&#125;</code></p><p>参考countingTest.dl</p><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><p>字符串拼接：<code>cat(x,y)</code></p><p>字符串长度：<code>strlen(x)</code></p><p>求子串：<code>substr(x,idx,len)</code></p><p>转化函数：<code>to_string(x)</code></p><p>Constraints:</p><p>子串：<code>contains(sub,str)</code></p><p>正则表达式：<code>match(regexpr,str)</code></p><h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>使用<code>.type</code>定义新的类型。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.type Mytype = number</span><br><span class="line">.decl A(x:Mytype)</span><br></pre></td></tr></table></figure><h4 id="Records"><a href="#Records" class="headerlink" title="Records"></a>Records</h4><p>使用<code>[x1:type1,...,xk:typek]</code>定义Records，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.type IntPair = [l:number, r:number]</span><br><span class="line">.type IntList = [x:number, xs:IntList]</span><br><span class="line">.decl edge(e:IntPair)</span><br><span class="line">.decl len(len:number, xs:IntList)</span><br></pre></td></tr></table></figure><p>Records可以定义一些递归类型。使用nil表示递归结束。</p><h4 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h4><p>使用符号 <code>&lt;:</code>定义子类，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.type City &lt;: symbol</span><br><span class="line">.type Town &lt;: symbol</span><br><span class="line">.type Village &lt;: symbol </span><br></pre></td></tr></table></figure><p> 使用$|$创建子类的union，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.type Position = City | Town | Village</span><br></pre></td></tr></table></figure><p>使用<code>as(expr,type)</code> 进行类型转换</p><h4 id="抽象数据类型ADT"><a href="#抽象数据类型ADT" class="headerlink" title="抽象数据类型ADT"></a>抽象数据类型ADT</h4><p>union只能表示由同一个基类生成的子类的并。如果要表示不同基类生成的子类，就必须使用ADT。</p><p>定义：<code>.type name = bname1 &#123; name11:type11, ..., name1k1:type1k1 &#125; | bname2 &#123; name21:type21, ..., name2k2:type2k2&#125; | ...</code></p><p><code>bnamei</code>表示一个<code>branch</code>的名字。使用<code>$bname(...)</code>选择一个分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.type T = N &#123;a:number&#125; | S &#123;b:symbol&#125; // Either a number or a symbol</span><br><span class="line">.decl A(p: T)  // set of numbers or symbols</span><br><span class="line">A($N(1)). </span><br><span class="line">A($S(“hello world”)).</span><br><span class="line">// Flatten relation A</span><br><span class="line">.decl Flatten(a:number, b:symbol) </span><br><span class="line">Flatten(a, ””) :- A($N(a)).</span><br><span class="line">Flatten(0, b) :- A($S(b)).  </span><br></pre></td></tr></table></figure><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>Soufflé 有组件这个概念，可用于模块化大型逻辑程序。一个组件可能包含其他组件、关系、类型声明、事实、规则和指令；组件必须声明和实例化后才可以使用，每个组件都有自己的命名空间；组件可以继承一个或多个超级组件。</p><p>声明组件使用<code>.comp</code>，使用<code>.init</code>初始化组件。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.comp TestComponent &#123;</span><br><span class="line">    .type MyType = number</span><br><span class="line">    .decl Rel(x: MyType)</span><br><span class="line">    Rel(0).</span><br><span class="line">&#125;</span><br><span class="line">.init TestInstance = TestComponent</span><br><span class="line">TestInstance.Rel(10).</span><br><span class="line">.output TestInstance.Rel</span><br></pre></td></tr></table></figure><p>组件的定义可以进行嵌套。</p><h4 id="组件参数传递"><a href="#组件参数传递" class="headerlink" title="组件参数传递"></a>组件参数传递</h4><p>可以使用类似泛型的概念。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.comp ParamComponent&lt;myType&gt; &#123;</span><br><span class="line">    .decl TheAnswer(x:myType)    // component relation</span><br><span class="line">    TheAnswer(42).               // component fact</span><br><span class="line">    .output TheAnswer            // component output directive</span><br><span class="line">&#125;</span><br><span class="line">.init numberInstance = ParamComponent&lt;number&gt;</span><br><span class="line">.init floatInstance = ParamComponent&lt;float&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.decl R(x:number)</span><br><span class="line">.comp Case&lt;Selector&gt; &#123;</span><br><span class="line">   .comp One &#123; </span><br><span class="line">     R(1). </span><br><span class="line">   &#125; </span><br><span class="line">   .comp Two &#123; </span><br><span class="line">     R(2).</span><br><span class="line">   &#125; </span><br><span class="line">   .init selection = Selector // instantiation depending on type parameter &quot;Selector&quot; </span><br><span class="line">&#125; </span><br><span class="line">.init myCase = Case&lt;One&gt; </span><br><span class="line">.output R</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>一个组件可以继承其他的组件，这样可以包含其他组件中的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.comp Base1 &#123;</span><br><span class="line">    .type myNumber = number</span><br><span class="line">    .decl TheAnswer(x:myNumber)</span><br><span class="line">    TheAnswer(42).</span><br><span class="line">&#125;</span><br><span class="line">.comp Base2 &#123; </span><br><span class="line">    TheAnswer(41). </span><br><span class="line">&#125;</span><br><span class="line">.comp Sub  : Base1, Base2 &#123; // inherit from Base1 and Base2</span><br><span class="line">    .decl WhatIsTheAnswer(n:myNumber)</span><br><span class="line">    WhatIsTheAnswer(n) :- TheAnswer(n).</span><br><span class="line">    .output WhatIsTheAnswer</span><br><span class="line">&#125;</span><br><span class="line">.init mySub = Sub</span><br></pre></td></tr></table></figure><h4 id="可重写关系"><a href="#可重写关系" class="headerlink" title="可重写关系"></a>可重写关系</h4><p>使用overridable声明关系使其在继承时可以被覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.comp Base &#123;</span><br><span class="line">    .decl R(x:number) overridable</span><br><span class="line">    R(1).</span><br><span class="line">    R(x+1) :- R(x), x &lt; 5. </span><br><span class="line">    .output R</span><br><span class="line">&#125;</span><br><span class="line">.comp Sub : Base &#123;</span><br><span class="line">    .override R</span><br><span class="line">    R(2).</span><br><span class="line">    R(x+1) :- R(x), x &lt; 4. </span><br><span class="line">&#125;</span><br><span class="line">.init mySub = Sub</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://souffle-lang.github.io/tutorial">Tutorial | Soufflé</a></p><p><a href="https://jckling.github.io/2021/11/22/Other/Datalog%20%E5%BC%95%E6%93%8E%20Souffl%C3%A9%20%E6%8C%87%E5%8D%97/">Datalog 引擎 Soufflé 指南 - Jckling’s Blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> datalog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-Aho-2</title>
      <link href="/2022/07/05/compilers_principles_aho_2/"/>
      <url>/2022/07/05/compilers_principles_aho_2/</url>
      
        <content type="html"><![CDATA[<p>我们首先关注编译中分析的部分。分析阶段的工作是围绕着语言的“语法”展开的。一个语言的语法描述了该语言的程序的正确形式。</p><p>我们将使用上下文无关文法描述语言的语法。</p><h2 id="语法定义"><a href="#语法定义" class="headerlink" title="语法定义"></a>语法定义</h2><h3 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h3><p>一个上下文无关文法由以下几个部分组成：</p><blockquote><ol><li><p>一个起始符号</p></li><li><p>一个合法符号集合</p></li><li><p>终止符号集合</p></li><li><p>一个推导规则的集合，也称之为产生式(production)的集合，包括左侧的<strong>一个非终止符号</strong>，称为产生式头，和右侧的一个符号序列。</p></li></ol></blockquote><p>由起始符号开始，经过若干次推导规则的作用，最终得到的由终止符号集合中的符号构成的一个序列就是一个合法的序列。</p><p>比如，我们可以给IMP语言的语法一个定义：</p><script type="math/tex; mode=display">\begin{array}{rcl}    stmt&\to&\textbf{skip}\\    &|&\textbf{id }:=aexpr\\    &|&\textbf{if  }bexpr\textbf{  then  }stmts\textbf{  else  } stmts\textbf{  end}\\    &|&\textbf{while  }bexpr\textbf{  do  }stmts\textbf{  end}\end{array}</script><script type="math/tex; mode=display">stmts\to stmt|stmts;stmt</script><script type="math/tex; mode=display">aexpr\to aterm|aexpr*aterm</script><script type="math/tex; mode=display">aterm\to afactor|aterm + afactor|aterm-afactor</script><script type="math/tex; mode=display">afactor\to \textbf{id}|\textbf{nat}|(aexpr)</script><script type="math/tex; mode=display">bexpr\to true|false|aexpr=aexpr|aexpr\le aexpr|\lnot bexpr|bexpr\&\&bexpr</script><p>其中，黑体字即为终止符号集合，起始符号即为stmts。</p><p>从任意一个非终结符号作用生成式多次后，我们可以得到一个由零个或多个终止符号构成的序列。零个终止符号的序列即空串可以用$\epsilon$表示。</p><p>从起始符号开始得到的终止符号序列即为合法的程序。语法分析所做的工作就是找到一个从起始状态出发得到待分析的程序的过程。如果找不到，则报告语法错误。</p><h3 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h3><p>语法分析树可以用图形的方式来描述上下文无关文法解析一个序列的过程。</p><p>给定一个上下文无关文法的解析过程，可以按照下面的方法构建语法分析树：</p><blockquote><ol><li><p>根节点标号为起始符号</p></li><li><p>每个叶子节点标号为一个终止符号或$\epsilon$</p></li><li><p>每个内部节点标号为一个非终止符号</p></li><li><p>每个标号为$A$的内部节点如果有从左到右标号依次为$X_1,X_2,\cdots,X_k$的儿子，那么有对应的推导规则$A\to X_1X_2\cdots X_k$</p></li></ol></blockquote><p>一个语法分析树的叶子节点从左到右构成了树的结果(yield)，即推导得到的符号串。</p><h3 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h3><p>在根据一个文法讨论某个符号串的结构时，我们可能会找到多个语法分析树生成同一个符号串。这样的文法称为有二义性(ambiguous)的。</p><p>例如，假设我们现在要定义一个仅由加减构成的运算式，如果我们使用如下定义：</p><script type="math/tex; mode=display">expr\to \textbf{id}|\textbf{nat}|expr+expr|expr-expr|(expr)</script><p>那么对于同一个符号串$9-5+2$，我们可以将其解析为$(9-5)+2$或$9-(5+2)$，这两种解析很显然是完全不同的。</p><p>使用一个更恰当的定义：</p><script type="math/tex; mode=display">expr \to factor|expr + factor|expr - factor</script><script type="math/tex; mode=display">factor\to \textbf{id}|\textbf{nat}|(expr)</script><p>可以消除这里的二义性。在这里，加减法是左结合的。</p><p>同样，对于右结合的运算符，我们也可以定义：</p><script type="math/tex; mode=display">right \to \textbf{id} = right|\textbf{id}</script><p>使用这个定义，我们可以得到没有二义性的形如$a=b=c$的连等号。</p><p>同时，我们还要考虑优先级的问题。在前面的IMP的例子中，我们已经看到了，我们可以将优先级较低的运算放在前面进行解析，保证解析的正确性。</p><h2 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h2><p>通过向产生式中加入一些规则，我们可以实现语法制导翻译。首先，我们构造语法分析树，按照需要构造属性依赖图，然后遍历语法树并按照语义规则进行计算。</p><p>属性(attribute)表示与程序构造相关的量。我们可以将属性扩展到文法符号上。</p><p>翻译方案(translation scheme)即是在语法树上遍历时的规则。</p><h3 id="综合属性"><a href="#综合属性" class="headerlink" title="综合属性"></a>综合属性</h3><p>如果一个语法分析树上各个节点标记了相应的属性值，那么这个语法分析书就称为注释语法分析树。</p><p>如果要求出语法树上某个属性时，只需要用到当前节点的符号和子节点的属性，那么称这个属性为综合属性(synthesized attribute)。如果只需要用到当前节点符号和父节点和兄弟节点，那么称这个属性为继承属性。</p><h3 id="语法制导定义"><a href="#语法制导定义" class="headerlink" title="语法制导定义"></a>语法制导定义</h3><p>把每个符号与一个属性集合进行关联，并把每个推导规则和一个语义规则进行关联。</p><p>例如，我们将在二义性一节中定义的没有二义性的表达式定义转为逆波兰表达式。</p><div class="table-container"><table><thead><tr><th style="text-align:center">推导规则</th><th style="text-align:center">语义规则</th></tr></thead><tbody><tr><td style="text-align:center">$expr\to factor$</td><td style="text-align:center">$expr.t=factor.t$</td></tr><tr><td style="text-align:center">$expr\to expr+factor$</td><td style="text-align:center">$expr.t=expr.t\mid\mid factor.t\mid\mid” + “$</td></tr><tr><td style="text-align:center">$expr\to expr-factor$</td><td style="text-align:center">$expr.t=expr.t\mid\mid factor.t\mid\mid” - “$</td></tr><tr><td style="text-align:center">$factor\to \textbf{id}$</td><td style="text-align:center">$factor.t=”\textbf{id}”$</td></tr><tr><td style="text-align:center">$factor\to \textbf{nat}$</td><td style="text-align:center">$factor.t=”\textbf{nat}”$</td></tr><tr><td style="text-align:center">$factor\to (expr)$</td><td style="text-align:center">$factor.t=expt.t$</td></tr></tbody></table></div><p>如果对于一个推导规则，只需要将其右边各个非终结符按照出现顺序排列并穿插一些附加串，则称为简单语法制导定义。</p><h3 id="翻译方案"><a href="#翻译方案" class="headerlink" title="翻译方案"></a>翻译方案</h3><p>在推导规则中加入一些程序片段，在解析时运行，即可形成翻译方案。这些程序片段被称为语义动作。</p><div class="table-container"><table><thead><tr><th style="text-align:center">推导规则</th><th style="text-align:center">语义动作</th></tr></thead><tbody><tr><td style="text-align:center">$expr\to factor$</td><td style="text-align:center">$expr\to factor$</td></tr><tr><td style="text-align:center">$expr\to expr+factor$</td><td style="text-align:center">$expr\to expr + factor\ \{print(+)\}$</td></tr><tr><td style="text-align:center">$expr\to expr-factor$</td><td style="text-align:center">$expr\to expr - factor\ \{print(-)\}$</td></tr><tr><td style="text-align:center">$factor\to \textbf{id}$</td><td style="text-align:center">$factor\to \textbf{id}\ \{print(\textbf{id})\}$</td></tr><tr><td style="text-align:center">$factor\to \textbf{nat}$</td><td style="text-align:center">$factor\to \textbf{nat}\ \{print(\textbf{nat})\}$</td></tr><tr><td style="text-align:center">$factor\to (expr)$</td><td style="text-align:center">$factor\to expr$</td></tr></tbody></table></div><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>语法分析是决定如何使用一个文法生成一个终结符号串的过程。</p><p>大多数语法分析可以分为自顶向下和自底向上两类。自顶向下可以手动实现一个高效的语法分析器，而自底向上可以处理更多种文法和翻译方案。</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 上下文无关文法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-Aho-1</title>
      <link href="/2022/06/30/compilers_principles_aho_1/"/>
      <url>/2022/06/30/compilers_principles_aho_1/</url>
      
        <content type="html"><![CDATA[<p>编译器(compiler)就是将用一种语言编写的程序转化为等价的用目标语言编写的程序的一个程序。解释器(interpreter)是另一种常见的语言处理器，并不通过翻译的方式生成目标程序，而是直接利用用户提供的输入执行源程序中指定的操作。编译器生成的程序通常要比解释器快很多，但解释器的错误诊断效果通常比编译器更好。</p><p>一个源程序可能被分割为多个部分，并存放在独立的文件中。把源程序聚合在一起的任务由预处理器(preprocessor)独立完成。</p><p>将经过预处理器处理的程序作为输入传递给一个编译器，一般由编译器转为一个汇编语言程序作为输出，并由汇编器(assembler)处理生成可重定位的机器代码。</p><p>在大型的程序中，可重定位的机器代码通常要和其他的可重定位目标文件以及库文件连接在一起，形成真正运行的代码。外部内存地址的问题由链接器(linker)解决，最后加载器(loader)把所有可执行文件放到内存中执行。</p><h2 id="编译器的结构"><a href="#编译器的结构" class="headerlink" title="编译器的结构"></a>编译器的结构</h2><p>编译器将源程序映射为语义上等价的目标程序。映射的过程分为两个方面：分析(analysis)和综合(synthesis)。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>通常来说，编译的第一个步骤称为词法分析(lexical analysis)或扫描(scanning)。词法分析器读入源程序，将它们组成为有意义的词素(lexeme)序列。每个词素由一个词法单元(token)<code>&lt;token-name, attribute-value&gt;</code>构成。token-name是下一个步骤中要用到的符号，attribute-value是与符号表相关的信息。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>编译的第二个步骤称为语法分析(syntax analysis)或解析(parsing)。语法分析器利用词法分析器得到的词法单元的第一个分量创建树形的中间表示，如语法树(syntax tree)。给出了词法分析器产生的词法单元流的语法结构。</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语义分析器(semantic analysis)使用语法树和符号表中的信息来检查程序是否和语言定义的语义一致，并将这些信息存放在语法树或符号表中。同时收集类型信息，进行类型检查(type checking)。</p><h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>在语法分析和语义分析完成后，编译器一般会生成一个明确的低级的或类机器语言的中间表示。可以将这个中间表示看作在一个虚拟的机器上执行的程序。这个中间表示一般要满足易于生成并能较为轻松地翻译为目标语言。</p><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>机器无关的代码优化通过改进中间代码，以期望生成更好的目标代码。此外还有机器相关的优化。</p><p>代码优化必须满足下面的设计目标：</p><ol><li><p>优化必须是正确的，不能改变被编译程序的含义。</p></li><li><p>优化必须能够改善很多程序的性能。</p></li><li><p>优化需要的时间必须保持在合理的区间内。</p></li><li><p>所需要的工程方面的工作必须是可管理的。</p></li></ol><h3 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h3><p>代码生成器以中间形式作为输入，映射到目标语言。如果目标语言是机器语言，那么就要为每个变量选择寄存器或内存地址。代码生成的一个至关重要的方面是合理分配寄存器以存放变量的值。</p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>编译器在编译的过程中要记录源程序中使用的变量和过程的各种属性。这些由符号表来完成。</p><p>以上中的若干个步骤进行组合称为一趟(pass)。</p><h2 id="程序设计语言"><a href="#程序设计语言" class="headerlink" title="程序设计语言"></a>程序设计语言</h2><p>分类方式：</p><p>按代际来划分：第一代：机器语言；第二代：汇编语言；第三代：Fortran,Cobol,Lisp,C,C++,Java等高级语言；第四代是为特定应用设计的语言如用于生成报告的NOMAD，用于数据库查询的SQL等；第五代指基于逻辑和约束的语言，如Prolog和OPS5。</p><p>将程序中指明如何完成一个计算任务的语言称为强制式(imperative)语言，如C,C++,Java等；将程序中指明要进行哪些计算任务的语言称为声明式(declarative)语言，如Haskell,Prolog等。</p><p>冯·诺依曼语言(von Neumann language)是指以冯·诺伊曼计算机体系结构为计算模型的语言。</p><p>面向对象语言(object-oriented language)指的是支持面向对象编程的语言。</p><p>脚本语言(scripting language)是具有高层次运算符的解释型语言。</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语义学简介</title>
      <link href="/2022/06/29/formal_semantics/"/>
      <url>/2022/06/29/formal_semantics/</url>
      
        <content type="html"><![CDATA[<p>如果要描述一个语言，我们需要描述三个方面的内容：字符集(alphabet)、语法(syntax)、语义(semantics)。对于一个程序设计语言来说也是如此。</p><p>语言的语法决定了我们能够写出来怎样的程序，而语义则决定了不同程序执行的具体的效果。</p><p>在写程序的时候，我们往往比较关注语言的语法，以写出能够被接受的程序。但同时，语言的语义也相当重要。有了恰当定义的语义，我们才能对程序运行的行为进行准确的描述，给定解释程序的标准，同时这也是进行程序分析的基础。</p><p>实际上，说明一个程序的正确性要比写出这个程序困难的多，一个正确定义的语义是保证程序正确性的重要条件。</p><h3 id="内存-State"><a href="#内存-State" class="headerlink" title="内存(State)"></a>内存(State)</h3><p>程序在运行的时候，必然要涉及内存的状态，及变量的值等。要描述程序运行的行为，就必须要对计算机的内存状态给出定义。</p><p>我们将内存抽象为一个从变量到值的映射，定义为一个状态(State)，如$(x\mapsto a;y\mapsto b;z\mapsto c)$。状态会随着程序的运行而发生变化。而语义就是描述了一个程序将一个状态转移到了另一个状态。</p><p>下面考虑一个简单的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z := x;</span><br><span class="line">x := y;</span><br><span class="line">y := z;</span><br></pre></td></tr></table></figure><h3 id="操作语义-Operational-Semantics"><a href="#操作语义-Operational-Semantics" class="headerlink" title="操作语义(Operational Semantics)"></a>操作语义(Operational Semantics)</h3><p>操作语义将一个程序执行的行为解释为初始状态经过一个程序后得到一个最终状态。</p><p>比如在$st=(x\mapsto a;y\mapsto b;z\mapsto c)$上运行程序<code>z := x; x := y; y := z</code>。</p><p>这里我们会用到两条推导规则：</p><script type="math/tex; mode=display">\begin{array}{c}    st\ a = n\\\hline    st =[x := a]\Rightarrow (x\mapsto n; st)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    st =[c_1]\Rightarrow st'\ \ \ st' =[c_2]\Rightarrow st''\\\hline    st =[c_1;c_2]\Rightarrow st''\end{array}</script><p>有了这两条推导规则，我们可以得到，</p><script type="math/tex; mode=display">\begin{array}{c}    (x\mapsto a;y\mapsto b;z\mapsto c)\ x = a\\\hline    (x\mapsto a;y\mapsto b;z\mapsto c) =[z := x]\Rightarrow (x\mapsto a;y\mapsto b;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    (x\mapsto a;y\mapsto b;z\mapsto c)\ y = b\\\hline    (x\mapsto a;y\mapsto b;z\mapsto a) =[x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}        (x\mapsto a;y\mapsto b;z\mapsto c) =[z := x]\Rightarrow (x\mapsto a;y\mapsto b;z\mapsto a)\\        (x\mapsto a;y\mapsto b;z\mapsto a) =[x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)    \\\hline    (x\mapsto a;y\mapsto b;z\mapsto c) =[z := x; x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}        (x\mapsto b;y\mapsto b;z\mapsto a)\ z = a    \\\hline    (x\mapsto b;y\mapsto b;z\mapsto a) =[y := z]\Rightarrow (x\mapsto b;y\mapsto a;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}(x\mapsto a;y\mapsto b;z\mapsto c) =[z := x; x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)\\    (x\mapsto b;y\mapsto b;z\mapsto a) =[y := z]\Rightarrow (x\mapsto b;y\mapsto a;z\mapsto a)\\\hline(x\mapsto a;y\mapsto b;z\mapsto c) =[z := x; x := y; y := z]\Rightarrow  (x\mapsto b;y\mapsto a;z\mapsto a)\end{array}</script><p>证明了程序的正确性。</p><h3 id="指称语义-Denotational-Semantics"><a href="#指称语义-Denotational-Semantics" class="headerlink" title="指称语义(Denotational Semantics)"></a>指称语义(Denotational Semantics)</h3><p>指称语义将程序抽象为一个数学上的函数。比如，要描述程序对状态的影响，我们可以把程序看作$State\to State$的函数。</p><p>比如在$st=(x\mapsto a;y\mapsto b;z\mapsto c)$上运行程序<code>z := x; x := y; y := z</code>。</p><p>这里我们会用到两条推导规则：</p><script type="math/tex; mode=display">[\![ s_1; s_2 ]\!] = [\![ s_2 ]\!]\circ [\![s_1]\!]</script><script type="math/tex; mode=display">([\![ x := v]\!]\ st)\ y = \left\{\begin{array}{ll}st\ y& ,y\not =x\\v& ,otherwise\end{array}\right.</script><p>由此，我们可以得到，</p><script type="math/tex; mode=display">\begin{array}{rcl}    [\![z := x; x := y; y := z]\!](x\mapsto a;y\mapsto b;z\mapsto c)&=&\\    [\![ y := z]\!]\circ [\![x := y]\!]\circ[\![z := x]\!](x\mapsto a;y\mapsto b;z\mapsto c)&=&\\    [\![ y := z]\!]\circ [\![x := y]\!](x\mapsto a;y\mapsto b;z\mapsto a)&=&\\    [\![ y := z]\!](x\mapsto b;y\mapsto b;z\mapsto a)&=&(x\mapsto b;y\mapsto a;z\mapsto a)\\\end{array}</script><p>不难发现，操作语义和指称语义的原理是几乎相同的，区别只在于描述不同。</p><h3 id="公理语义-Axiomatic-Semantics"><a href="#公理语义-Axiomatic-Semantics" class="headerlink" title="公理语义(Axiomatic Semantics)"></a>公理语义(Axiomatic Semantics)</h3><p>公理语义更关注程序的性质，通过一系列的公理推出程序在某些状态上符合的某个定理。</p><p>如一个最著名的实例，霍尔逻辑(Hoare Logic)。霍尔逻辑由霍尔三元组来描述，其由三个部分即前条件(pre-condition)、程序和后条件(post-condition)组成。其含义为程序在满足前条件的状态上运行得到的状态满足后条件。如$\{P\}c\{Q\}$</p><p>比如在$st=(x\mapsto a;y\mapsto b;z\mapsto c)$上运行程序<code>z := x; x := y; y := z</code>。</p><p>这里我们会用到两条推导规则：</p><script type="math/tex; mode=display">\begin{array}{c}    \{P\}c_1\{Q\}\ \ \ \{Q\}c_2\{R\}\\\hline    \{P\}c_1;c_2\{R\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{P[a/x]\}x:=a\{R\}\end{array}</script><p>其中$P[a/x]$指使用a替换P中的所有x，如$\{Y = 2\} X := Y \{X = 2\}$</p><p>通过上面两条规则，我们可以得到</p><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{x=a\land y=b\}z := x\{y=b\land z=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{y=b\land z=a\}x := y\{x=b\land z=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \{x=a\land y=b\}z := x\{y=b\land z=a\}\ \ \ \{y=b\land z=a\}x := y\{x=b\land z=a\}\\\hline    \{x=a\land y=b\}z := x; x := y\{x=b\land z=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{x=b\land z=a\}y := z\{x=b\land y=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \{x=a\land y=b\}z := x; x := y\{x=b\land z=a\}\ \ \ \{x=b\land z=a\}y := z\{x=b\land y=a\}\\\hline    \{x=a\land y=b\}z := x; x := y; y := z\{x=b\land y=a\}\end{array}</script><p>证明了程序关于交换的一个性质。</p>]]></content>
      
      
      <categories>
          
          <category> 形式语义 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 形式语义 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
