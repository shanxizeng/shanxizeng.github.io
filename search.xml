<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>形式语义学简介</title>
      <link href="/2022/06/29/formal_semantics/"/>
      <url>/2022/06/29/formal_semantics/</url>
      
        <content type="html"><![CDATA[<p>如果要描述一个语言，我们需要描述三个方面的内容：字符集(alphabet)、语法(syntax)、语义(semantics)。对于一个程序设计语言来说也是如此。</p><p>语言的语法决定了我们能够写出来怎样的程序，而语义则决定了不同程序执行的具体的效果。</p><p>在写程序的时候，我们往往比较关注语言的语法，以写出能够被接受的程序。但同时，语言的语义也相当重要。有了恰当定义的语义，我们才能对程序运行的行为进行准确的描述，给定解释程序的标准，同时这也是进行程序分析的基础。</p><p>实际上，说明一个程序的正确性要比写出这个程序困难的多，一个正确定义的语义是保证程序正确性的重要条件。</p><h3 id="内存-State"><a href="#内存-State" class="headerlink" title="内存(State)"></a>内存(State)</h3><p>程序在运行的时候，必然要涉及内存的状态，及变量的值等。要描述程序运行的行为，就必须要对计算机的内存状态给出定义。</p><p>我们将内存抽象为一个从变量到值的映射，定义为一个状态(State)，如$(x\mapsto a;y\mapsto b;z\mapsto c)$。状态会随着程序的运行而发生变化。而语义就是描述了一个程序将一个状态转移到了另一个状态。</p><p>下面考虑一个简单的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z := x;</span><br><span class="line">x := y;</span><br><span class="line">y := z;</span><br></pre></td></tr></table></figure><h3 id="操作语义-Operational-Semantics"><a href="#操作语义-Operational-Semantics" class="headerlink" title="操作语义(Operational Semantics)"></a>操作语义(Operational Semantics)</h3><p>操作语义将一个程序执行的行为解释为初始状态经过一个程序后得到一个最终状态。</p><p>比如在$st=(x\mapsto a;y\mapsto b;z\mapsto c)$上运行程序<code>z := x; x := y; y := z</code>。</p><p>这里我们会用到两条推导规则：</p><script type="math/tex; mode=display">\begin{array}{c}    st\ a = n\\\hline    st =[x := a]\Rightarrow (x\mapsto n; st)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    st =[c_1]\Rightarrow st'\ \ \ st' =[c_2]\Rightarrow st''\\\hline    st =[c_1;c_2]\Rightarrow st''\end{array}</script><p>有了这两条推导规则，我们可以得到，</p><script type="math/tex; mode=display">\begin{array}{c}    (x\mapsto a;y\mapsto b;z\mapsto c)\ x = a\\\hline    (x\mapsto a;y\mapsto b;z\mapsto c) =[z := x]\Rightarrow (x\mapsto a;y\mapsto b;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    (x\mapsto a;y\mapsto b;z\mapsto c)\ y = b\\\hline    (x\mapsto a;y\mapsto b;z\mapsto a) =[x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}        (x\mapsto a;y\mapsto b;z\mapsto c) =[z := x]\Rightarrow (x\mapsto a;y\mapsto b;z\mapsto a)\\        (x\mapsto a;y\mapsto b;z\mapsto a) =[x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)    \\\hline    (x\mapsto a;y\mapsto b;z\mapsto c) =[z := x; x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}        (x\mapsto b;y\mapsto b;z\mapsto a)\ z = a    \\\hline    (x\mapsto b;y\mapsto b;z\mapsto a) =[y := z]\Rightarrow (x\mapsto b;y\mapsto a;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}(x\mapsto a;y\mapsto b;z\mapsto c) =[z := x; x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)\\    (x\mapsto b;y\mapsto b;z\mapsto a) =[y := z]\Rightarrow (x\mapsto b;y\mapsto a;z\mapsto a)\\\hline(x\mapsto a;y\mapsto b;z\mapsto c) =[z := x; x := y; y := z]\Rightarrow  (x\mapsto b;y\mapsto a;z\mapsto a)\end{array}</script><p>证明了程序的正确性。</p><h3 id="指称语义-Denotational-Semantics"><a href="#指称语义-Denotational-Semantics" class="headerlink" title="指称语义(Denotational Semantics)"></a>指称语义(Denotational Semantics)</h3><p>指称语义将程序抽象为一个数学上的函数。比如，要描述程序对状态的影响，我们可以把程序看作$State\to State$的函数。</p><p>比如在$st=(x\mapsto a;y\mapsto b;z\mapsto c)$上运行程序<code>z := x; x := y; y := z</code>。</p><p>这里我们会用到两条推导规则：</p><script type="math/tex; mode=display">[\![ s_1; s_2 ]\!] = [\![ s_2 ]\!]\circ [\![s_1]\!]</script><script type="math/tex; mode=display">([\![ x := v]\!]\ st)\ y = \left\{\begin{array}{ll}st\ y& ,y\not =x\\v& ,otherwise\end{array}\right.</script><p>由此，我们可以得到，</p><script type="math/tex; mode=display">\begin{array}{rcl}    [\![z := x; x := y; y := z]\!](x\mapsto a;y\mapsto b;z\mapsto c)&=&\\    [\![ y := z]\!]\circ [\![x := y]\!]\circ[\![z := x]\!](x\mapsto a;y\mapsto b;z\mapsto c)&=&\\    [\![ y := z]\!]\circ [\![x := y]\!](x\mapsto a;y\mapsto b;z\mapsto a)&=&\\    [\![ y := z]\!](x\mapsto b;y\mapsto b;z\mapsto a)&=&(x\mapsto b;y\mapsto a;z\mapsto a)\\\end{array}</script><p>不难发现，操作语义和指称语义的原理是几乎相同的，区别只在于描述不同。</p><h3 id="公理语义-Axiomatic-Semantics"><a href="#公理语义-Axiomatic-Semantics" class="headerlink" title="公理语义(Axiomatic Semantics)"></a>公理语义(Axiomatic Semantics)</h3><p>公理语义更关注程序的性质，通过一系列的公理推出程序在某些状态上符合的某个定理。</p><p>如一个最著名的实例，霍尔逻辑(Hoare Logic)。霍尔逻辑由霍尔三元组来描述，其由三个部分即前条件(pre-condition)、程序和后条件(post-condition)组成。其含义为程序在满足前条件的状态上运行得到的状态满足后条件。如$\{P\}c\{Q\}$</p><p>比如在$st=(x\mapsto a;y\mapsto b;z\mapsto c)$上运行程序<code>z := x; x := y; y := z</code>。</p><p>这里我们会用到两条推导规则：</p><script type="math/tex; mode=display">\begin{array}{c}    \{P\}c_1\{Q\}\ \ \ \{Q\}c_2\{R\}\\\hline    \{P\}c_1;c_2\{R\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{P[a/x]\}x:=a\{R\}\end{array}</script><p>其中$P[a/x]$指使用a替换P中的所有x，如$\{Y = 2\} X := Y \{X = 2\}$</p><p>通过上面两条规则，我们可以得到</p><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{x=a\land y=b\}z := x\{y=b\land z=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{y=b\land z=a\}x := y\{x=b\land z=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \{x=a\land y=b\}z := x\{y=b\land z=a\}\ \ \ \{y=b\land z=a\}x := y\{x=b\land z=a\}\\\hline    \{x=a\land y=b\}z := x; x := y\{x=b\land z=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{x=b\land z=a\}y := z\{x=b\land y=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \{x=a\land y=b\}z := x; x := y\{x=b\land z=a\}\ \ \ \{x=b\land z=a\}y := z\{x=b\land y=a\}\\\hline    \{x=a\land y=b\}z := x; x := y; y := z\{x=b\land y=a\}\end{array}</script><p>证明了程序关于交换的一个性质。</p>]]></content>
      
      
      <categories>
          
          <category> 形式语义 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 形式语义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/06/27/test/"/>
      <url>/2022/06/27/test/</url>
      
        <content type="html"><![CDATA[<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn=<span class="number">110000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> to[Maxn],nxt[Maxn],first[Maxn],tot=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    to[tot]=v;</span><br><span class="line">    nxt[tot]=first[u];</span><br><span class="line">    first[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\sum_{i=1}^n i^2=\frac{n(n+1)(2n+1)}{6}</script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
