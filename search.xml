<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>指称语义</title>
      <link href="/2022/09/13/denotational_semantics/"/>
      <url>/2022/09/13/denotational_semantics/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>从指称语义的视角看，每个程序段(phrase),$P$,都对应一个指称(denotation),$[\![P]\!]$，表示其在程序中产生的影响。</p><p>一段程序的指称只与其子段有关，也即上下文无关。</p><p>下面以一个简单的语言$\texttt{IMP}^-$为例。</p><p>我们定义算数表达式：</p><script type="math/tex; mode=display">A\in Aexp ::= \underline{n}|L|A+A|\cdots</script><p>其中，$\underline{n}$代表常数值，$L\in \mathbb{L}$代表内存中的位置。</p><p>定义布尔表达式：</p><script type="math/tex; mode=display">B\in Bexp ::=\textbf{true}|\textbf{false}|A=A|\cdots|\lnot B|B\land B|\cdots</script><p>定义程序指令：</p><script type="math/tex; mode=display">C\in Comm ::= \textbf{skip}|L:=A|C;C|\textbf{if}\ B\ \textbf{then}\ C\ \textbf{else}\ C</script><p>对于每一个表达式，我们都可以对应一个指称，即关于程序状态(state)的一个映射（函数），从前一个状态转移到下一个状态。</p><script type="math/tex; mode=display">\begin{array}{l}    \mathcal{A}:\ Aexp\to(State\to \mathbb{Z})\\    \mathcal{B}:\ Bexp\to(State\to \mathbb{B})\\    \mathcal{C}:\ Comm\to(State\rightharpoonup State)\\\end{array}</script><script type="math/tex; mode=display">\begin{array}{rcl}    \mathbb{Z}&=&\{\dots,-1,0,1,\dots\}\\    \mathbb{B}&=&\{true,false\}\\    State&=&(\mathbb{L}\to\mathbb{Z})\end{array}</script><p>$State$即程序的状态，是一个由内存位置到整数的映射。</p><p>我们可以对$\mathcal{A},\mathcal{B},\mathcal{C}$参考前面的表达式进行定义。</p><script type="math/tex; mode=display">\begin{array}{rcl}    \mathcal{A}[\![\underline{n}]\!]&=&\lambda s\in State.n\\    \mathcal{A}[\![L]\!]&=&\lambda s\in State.S(L)\\    \mathcal{A}[\![A_1+A_2]\!]&=&\lambda s\in State.        \mathcal{A}[\![A_1]\!](s)+        \mathcal{A}[\![A_2]\!](s)\\        &\vdots&\end{array}</script><p>定义了算数表达式的语义。</p><script type="math/tex; mode=display">\begin{array}{rcl}    \mathcal{B}[\![true]\!]&=&\lambda s\in State.true\\    \mathcal{B}[\![false]\!]&=&\lambda s\in State.false\\    \mathcal{B}[\![A_1=A_2]\!]&=&\lambda s\in State.eq(        \mathcal{A}[\![A_1]\!](s),        \mathcal{A}[\![A_2]\!](s))\\        &&where\ eq(a,a')=            \left\{\begin{array}{ll}                true&,if\ a=a'\\                false&,if\ a\not=a'            \end{array}\right.\\            &\vdots&\\    \mathcal{B}[\![B_1\land B_2]\!]&=&\lambda s\in State.and(        \mathcal{B}[\![B_1]\!](s),        \mathcal{B}[\![B_2]\!](s))\\        &\vdots&\end{array}</script><p>定义了布尔表达式的语义。</p><p>下面定义程序语句的语义：(下面省略函数名)</p><script type="math/tex; mode=display">\begin{array}{rcl}    [\![\textbf{skip}]\!]&=&\lambda s\in State.s\\    [\![L:=A]\!]&=&\lambda s\in State.        \lambda l\in \mathbb{L}.if(l=L,[\![A]\!](s),s(l))\\        &&where\ if(b,x,x')=\left\{\begin{array}{ll}            x&,if\ b=true\\            x'&,if\ b=false        \end{array}\right.\\    [\![C;C']\!]&=&[\![C]\!]\circ[\![C']\!]=        \lambda s\in State.[\![C']\!]([\![C]\!](s))\\    [\![\textbf{if}\ B\ \textbf{then}\ C\ \textbf{else}\ C]\!]&=&        \lambda s\in State.if([\![B]\!](s),[\![C]\!](s),[\![C']\!](s))\end{array}</script><p>下面我们考虑如何引入while。</p><p>在$\texttt{IMP}$语言中，while语句的定义可以是：</p><p>$\textbf{while}\ B\ \textbf{do}\ C$</p><p>从程序执行的角度上看，我们已经知道，</p><script type="math/tex; mode=display">[\![\textbf{while}\ B\ \textbf{do}\ C]\!]=[\![\textbf{if}\ B\ \textbf{then}\ C;(\textbf{while}\ B\ \textbf{do}\ C)\ \textbf{else}\ \textbf{skip}]\!]</script><p>因此，我们定义一个程序的函数</p><script type="math/tex; mode=display">f_{b,c}=\lambda\omega\in(State\to State).\lambda s\in State.if(b(s),\omega(c(s)),s)</script><p>那么我们就有：</p><script type="math/tex; mode=display">[\![\textbf{while}\ B\ \textbf{do}\ C]\!]=f_{[\![B]\!][\![C]\!]}[\![\textbf{while}\ B\ \textbf{do}\ C]\!]</script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 形式语义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数算实习笔记</title>
      <link href="/2022/09/07/DSAPractice/"/>
      <url>/2022/09/07/DSAPractice/</url>
      
        <content type="html"><![CDATA[<h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><p>以下我们假设字符串从1开始编号。</p><p>编号为i的后缀即从位置i开始的后缀。</p><h3 id="后缀数组简介和求法"><a href="#后缀数组简介和求法" class="headerlink" title="后缀数组简介和求法"></a>后缀数组简介和求法</h3><p>后缀数组就是对一个字符串的所有的后缀进行排序（即后缀排序）的结果。得到的两个数组$sa$和$rk$，其中$sa[i]$表示排名为i的后缀的编号，即后缀数组，$rk[i]$表示编号为i的后缀的排名。两个数组满足性质$sa[rk[i]]=rk[sa[i]]=i$。</p><p>求后缀数组时可以使用倍增进行排序。首先求出所有后缀长度为i的前缀的排序，再将所有后缀长度为2i的前缀视为两个长度为i的串的组合，而这两个串都已经进行了排序，因此长度为2i的串可以视作由两个字符构成的串。那么我们对所有的串使用基数排序即可获得长度为2i的串的排序。不断进行倍增即可求出所有后缀的排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxn=;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[Maxn];</span><br><span class="line"><span class="type">int</span> n,sa[Maxn],rk[Maxn],oldrk[Maxn&lt;&lt;<span class="number">1</span>],id[Maxn],px[Maxn],cnt[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> m=<span class="number">127</span>,p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[rk[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[cnt[rk[i]]--]=i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;;w&lt;&lt;=<span class="number">1</span>,m=p) &#123;</span><br><span class="line">        p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;n-w;i--) id[++p]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">            <span class="keyword">if</span>(sa[i]&gt;w) id[++p]=sa[i]-w;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[px[i]=rk[id[i]]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[cnt[px[i]]--]=id[i];</span><br><span class="line">        <span class="built_in">memcpy</span>(oldrk+<span class="number">1</span>,rk+<span class="number">1</span>,n*<span class="built_in">sizeof</span>(<span class="type">int</span>)); p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(oldrk[sa[i]]==oldrk[sa[i<span class="number">-1</span>]]&amp;&amp;</span><br><span class="line">                oldrk[sa[i]+w]==oldrk[sa[i<span class="number">-1</span>]+w])</span><br><span class="line">                rk[sa[i]]=p;</span><br><span class="line">            <span class="keyword">else</span> rk[sa[i]]=++p;</span><br><span class="line">        <span class="keyword">if</span>(p==n) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sa[rk[i]]=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="height数组"><a href="#height数组" class="headerlink" title="height数组"></a>height数组</h3><p>height数组是一个非常强大的工具，配合后缀数组使用时可以解决许多复杂的问题。</p><h4 id="LCP"><a href="#LCP" class="headerlink" title="LCP"></a>LCP</h4><p>LCP(Longest Common Prefix)即为最长公共前缀。两个串$S$和$T$的最长公共前缀即为求出最大的一个$i$满足$i\le min(|S|,|T|)\land \forall x\in [1,i], S_x=T_x$</p><p>我们记$lcp(i,j)$为编号为i和j的两个后缀的最长公共前缀。</p><h4 id="height数组定义和求法"><a href="#height数组定义和求法" class="headerlink" title="height数组定义和求法"></a>height数组定义和求法</h4><p>$height[i]=lcp(sa[i],sa[i-1])$，即排名为i的串与其前一位的串的最长公共前缀。我们可以将$height[1]$视为0。</p><p>求height数组时，我们需要使用一个引理：</p><blockquote><p>$Lemma: height[rk[i]]&gt;height[rk[i-1]]-1$</p><p>$Proof.$ 如果$height[rk[i-1]]\le 1$，那么显然成立。</p><p>如果$height[rk[i-1]]&gt;1$，那么即有$lcp(sa[rk[i-1]],sa[rk[i-1]-1])&gt;1$，不妨设$i-1$和$sa[rk[i-1]-1]$的最长公共前缀为$aA$，后缀$i-1$为$aAD$，后缀$sa[rk[i-1]-1]$为$aAB(B\le D)$。</p><p>那么有后缀$i$为$AD$，后缀$sa[rk[i-1]-1]+1$为$AB$，则$rk[sa[rk[i-1]-1]+1]&lt;rk[i]$</p><p>因此$AB\le sa[rk[i]-1]\le AD$，则$sa[rk[i]-1]=AC,(B\le C\le D)$，即$height[rk[i]]=lcp(sa[rk[i]-1],i)\ge |A|=height[rk[i-1]]-1$。$Qed.$</p></blockquote><p>利用这个引理，我们就可以在$O(n)$的时间复杂度求出height数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,k=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k) k--;</span><br><span class="line">    <span class="keyword">while</span>(s[i+k]==s[sa[rk[i]<span class="number">-1</span>]+k]) k++;</span><br><span class="line">    height[rk[i]]=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了height数组，我们可以求出$lcp(i,j)=min_{k=rk[i]+1}^{rk[j]}height[k]$（不妨设$rk[i]&lt;rk[j]$）</p><p>那么求lcp就可以转为RMQ问题，使用倍增等算法即可求解。</p><h3 id="后缀数组应用举例"><a href="#后缀数组应用举例" class="headerlink" title="后缀数组应用举例"></a>后缀数组应用举例</h3><ol><li>查找子串</li></ol><p>在串$T$中查找是否包含串$S$：直接将$T$进行后缀排序，然后在$T$中二分查找即可。同时还可以方便地求出$S$出现的次数。</p><p>复杂度为$O(|T|log|T|+|S|log|T|)$</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据流分析</title>
      <link href="/2022/07/20/DFA/"/>
      <url>/2022/07/20/DFA/</url>
      
        <content type="html"><![CDATA[<p>程序可以看作是由状态和状态之间的转移（即数据流和控制流）组成。如果忽略了状态之间转移的条件，那么唯一需要考虑的就是数据流，即程序只剩下了数据流，因此将这个分析叫做数据流分析。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据流分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>datalog简易教程</title>
      <link href="/2022/07/08/datalog/"/>
      <url>/2022/07/08/datalog/</url>
      
        <content type="html"><![CDATA[<h2 id="DataLog"><a href="#DataLog" class="headerlink" title="DataLog"></a>DataLog</h2><p><a href="https://github.com/shanxizeng/datalog_test">github地址</a></p><h3 id="Souffle"><a href="#Souffle" class="headerlink" title="Souffle"></a><a href="https://github.com/souffle-lang/souffle">Souffle</a></h3><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>datalog是prolog的一个子集，主要表达数据及其关系。</p><p>Datalog 是一种（声明式）基于逻辑的查询语言，允许用户执行递归查询。Datalog 语法的规范没有统一的标准，通常采用 Prolog 风格的语法。Soufflé 的语法受到 Datalog 实现的启发，即 Z3 中的 bddbddb(BDD-Based Deductive DataBase) 和 muZ。</p><p>Soufflé 为大规模面向逻辑的编程提供了软件工程功能（例如组件），对于实际使用，Soufflé 通过算术函子（arithmetic functors）扩展了 Datalog 使其图灵等价，让程序员能够编写非终止的程序。</p><p>Soufflé 中的主要语言元素是关系声明（relation declarations）、事实（facts）、规则（rules）和指令（directives）。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>datalog中有两种基本类型：symbol和number。其中symbol包含了所有的字符串，而number中包含了所有的整数。datalog内部使用序数表示字符串，<code>ord(str)</code>表示其序数。</p><p>souffle中另外还有两种类型：float和unsigned。其中float包含了浮点数，unsigned包含了无符号整数。</p><p>souffle中支持各种基本代数运算（包括取余和取幂）以及位运算和逻辑运算（同C语言一样，1为true，0为false）。同时还有 autoinc()运算。autoinc()每次使用时产生一个新的值（从零开始）。autoinc不能在递归关系中使用。（参考autoincTest.dl）</p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>souffle中的关系必须声明。关系由一个列表<code>(x1,x2,...,xk)</code>组成。每个部分声明各自的类型。</p><p>使用<code>.decl &lt;rel-name&gt;(x1:type1, x2:type2, ..., xk:typek)</code>定义关系。</p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>使用<code>.input &lt;rel-name&gt;</code>和<code>.output &lt;rel-name&gt;</code>进行输入输出。从<code>&lt;rel-name&gt;.facts</code>中读取输入，并将输出存在<code>&lt;rel-name&gt;.csv</code>中。注意数据要用制表符分隔。</p><p>使用<code>.printsize &lt;rel-name&gt;</code>输出集合基数。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>规则是条件逻辑语句，由规则头和规则体组成。如<code>path(x,y) :- path(x,z),edge(z,y)</code></p><p>使用$!$对某个语句取非。注意为了保证单调性，在循环的定义中不能使用not。</p><h3 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h3><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>Soufflé 中的聚合是指使用特定的函子来汇总有关查询的信息，聚合类型包括计数、求最小值/最大值、求和。在 Soufflé 中，信息通常不能从子目标（聚合函子的参数）流到外部作用域。例如，如果希望找到关系 Cost(x) 的最小值，无法找到使成本最小化的特定 x 值，因为这样的 x 值可能不是唯一的。</p><p>计数：<code>count:&#123;&lt;sub-goal&gt;&#125;</code></p><p>最小：<code>max &lt;var&gt;:&#123;&lt;sub-goal(&lt;var&gt;)&gt;&#125;</code></p><p>最大：<code>min &lt;var&gt;:&#123;&lt;sub-goal(&lt;var&gt;)&gt;&#125;</code></p><p>求和：<code>sum &lt;var&gt;:&#123;&lt;sub-goal(&lt;var&gt;)&gt;&#125;</code></p><p>参考countingTest.dl</p><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><p>字符串拼接：<code>cat(x,y)</code></p><p>字符串长度：<code>strlen(x)</code></p><p>求子串：<code>substr(x,idx,len)</code></p><p>转化函数：<code>to_string(x)</code></p><p>Constraints:</p><p>子串：<code>contains(sub,str)</code></p><p>正则表达式：<code>match(regexpr,str)</code></p><h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>使用<code>.type</code>定义新的类型。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.type Mytype = number</span><br><span class="line">.decl A(x:Mytype)</span><br></pre></td></tr></table></figure><h4 id="Records"><a href="#Records" class="headerlink" title="Records"></a>Records</h4><p>使用<code>[x1:type1,...,xk:typek]</code>定义Records，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.type IntPair = [l:number, r:number]</span><br><span class="line">.type IntList = [x:number, xs:IntList]</span><br><span class="line">.decl edge(e:IntPair)</span><br><span class="line">.decl len(len:number, xs:IntList)</span><br></pre></td></tr></table></figure><p>Records可以定义一些递归类型。使用nil表示递归结束。</p><h4 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h4><p>使用符号 <code>&lt;:</code>定义子类，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.type City &lt;: symbol</span><br><span class="line">.type Town &lt;: symbol</span><br><span class="line">.type Village &lt;: symbol </span><br></pre></td></tr></table></figure><p> 使用$|$创建子类的union，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.type Position = City | Town | Village</span><br></pre></td></tr></table></figure><p>使用<code>as(expr,type)</code> 进行类型转换</p><h4 id="抽象数据类型ADT"><a href="#抽象数据类型ADT" class="headerlink" title="抽象数据类型ADT"></a>抽象数据类型ADT</h4><p>union只能表示由同一个基类生成的子类的并。如果要表示不同基类生成的子类，就必须使用ADT。</p><p>定义：<code>.type name = bname1 &#123; name11:type11, ..., name1k1:type1k1 &#125; | bname2 &#123; name21:type21, ..., name2k2:type2k2&#125; | ...</code></p><p><code>bnamei</code>表示一个<code>branch</code>的名字。使用<code>$bname(...)</code>选择一个分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.type T = N &#123;a:number&#125; | S &#123;b:symbol&#125; // Either a number or a symbol</span><br><span class="line">.decl A(p: T)  // set of numbers or symbols</span><br><span class="line">A($N(1)). </span><br><span class="line">A($S(“hello world”)).</span><br><span class="line">// Flatten relation A</span><br><span class="line">.decl Flatten(a:number, b:symbol) </span><br><span class="line">Flatten(a, ””) :- A($N(a)).</span><br><span class="line">Flatten(0, b) :- A($S(b)).  </span><br></pre></td></tr></table></figure><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>Soufflé 有组件这个概念，可用于模块化大型逻辑程序。一个组件可能包含其他组件、关系、类型声明、事实、规则和指令；组件必须声明和实例化后才可以使用，每个组件都有自己的命名空间；组件可以继承一个或多个超级组件。</p><p>声明组件使用<code>.comp</code>，使用<code>.init</code>初始化组件。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.comp TestComponent &#123;</span><br><span class="line">    .type MyType = number</span><br><span class="line">    .decl Rel(x: MyType)</span><br><span class="line">    Rel(0).</span><br><span class="line">&#125;</span><br><span class="line">.init TestInstance = TestComponent</span><br><span class="line">TestInstance.Rel(10).</span><br><span class="line">.output TestInstance.Rel</span><br></pre></td></tr></table></figure><p>组件的定义可以进行嵌套。</p><h4 id="组件参数传递"><a href="#组件参数传递" class="headerlink" title="组件参数传递"></a>组件参数传递</h4><p>可以使用类似泛型的概念。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.comp ParamComponent&lt;myType&gt; &#123;</span><br><span class="line">    .decl TheAnswer(x:myType)    // component relation</span><br><span class="line">    TheAnswer(42).               // component fact</span><br><span class="line">    .output TheAnswer            // component output directive</span><br><span class="line">&#125;</span><br><span class="line">.init numberInstance = ParamComponent&lt;number&gt;</span><br><span class="line">.init floatInstance = ParamComponent&lt;float&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.decl R(x:number)</span><br><span class="line">.comp Case&lt;Selector&gt; &#123;</span><br><span class="line">   .comp One &#123; </span><br><span class="line">     R(1). </span><br><span class="line">   &#125; </span><br><span class="line">   .comp Two &#123; </span><br><span class="line">     R(2).</span><br><span class="line">   &#125; </span><br><span class="line">   .init selection = Selector // instantiation depending on type parameter &quot;Selector&quot; </span><br><span class="line">&#125; </span><br><span class="line">.init myCase = Case&lt;One&gt; </span><br><span class="line">.output R</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>一个组件可以继承其他的组件，这样可以包含其他组件中的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.comp Base1 &#123;</span><br><span class="line">    .type myNumber = number</span><br><span class="line">    .decl TheAnswer(x:myNumber)</span><br><span class="line">    TheAnswer(42).</span><br><span class="line">&#125;</span><br><span class="line">.comp Base2 &#123; </span><br><span class="line">    TheAnswer(41). </span><br><span class="line">&#125;</span><br><span class="line">.comp Sub  : Base1, Base2 &#123; // inherit from Base1 and Base2</span><br><span class="line">    .decl WhatIsTheAnswer(n:myNumber)</span><br><span class="line">    WhatIsTheAnswer(n) :- TheAnswer(n).</span><br><span class="line">    .output WhatIsTheAnswer</span><br><span class="line">&#125;</span><br><span class="line">.init mySub = Sub</span><br></pre></td></tr></table></figure><h4 id="可重写关系"><a href="#可重写关系" class="headerlink" title="可重写关系"></a>可重写关系</h4><p>使用overridable声明关系使其在继承时可以被覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.comp Base &#123;</span><br><span class="line">    .decl R(x:number) overridable</span><br><span class="line">    R(1).</span><br><span class="line">    R(x+1) :- R(x), x &lt; 5. </span><br><span class="line">    .output R</span><br><span class="line">&#125;</span><br><span class="line">.comp Sub : Base &#123;</span><br><span class="line">    .override R</span><br><span class="line">    R(2).</span><br><span class="line">    R(x+1) :- R(x), x &lt; 4. </span><br><span class="line">&#125;</span><br><span class="line">.init mySub = Sub</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://souffle-lang.github.io/tutorial">Tutorial | Soufflé</a></p><p><a href="https://jckling.github.io/2021/11/22/Other/Datalog%20%E5%BC%95%E6%93%8E%20Souffl%C3%A9%20%E6%8C%87%E5%8D%97/">Datalog 引擎 Soufflé 指南 - Jckling’s Blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> datalog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-Aho-2</title>
      <link href="/2022/07/05/compilers_principles_aho_2/"/>
      <url>/2022/07/05/compilers_principles_aho_2/</url>
      
        <content type="html"><![CDATA[<p>我们首先关注编译中分析的部分。分析阶段的工作是围绕着语言的“语法”展开的。一个语言的语法描述了该语言的程序的正确形式。</p><p>我们将使用上下文无关文法描述语言的语法。</p><h2 id="语法定义"><a href="#语法定义" class="headerlink" title="语法定义"></a>语法定义</h2><h3 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h3><p>一个上下文无关文法由以下几个部分组成：</p><blockquote><ol><li><p>一个起始符号</p></li><li><p>一个合法符号集合</p></li><li><p>终止符号集合</p></li><li><p>一个推导规则的集合，也称之为产生式(production)的集合，包括左侧的<strong>一个非终止符号</strong>，称为产生式头，和右侧的一个符号序列。</p></li></ol></blockquote><p>由起始符号开始，经过若干次推导规则的作用，最终得到的由终止符号集合中的符号构成的一个序列就是一个合法的序列。</p><p>比如，我们可以给IMP语言的语法一个定义：</p><script type="math/tex; mode=display">\begin{array}{rcl}    stmt&\to&\textbf{skip}\\    &|&\textbf{id }:=aexpr\\    &|&\textbf{if  }bexpr\textbf{  then  }stmts\textbf{  else  } stmts\textbf{  end}\\    &|&\textbf{while  }bexpr\textbf{  do  }stmts\textbf{  end}\end{array}</script><script type="math/tex; mode=display">stmts\to stmt|stmts;stmt</script><script type="math/tex; mode=display">aexpr\to aterm|aexpr*aterm</script><script type="math/tex; mode=display">aterm\to afactor|aterm + afactor|aterm-afactor</script><script type="math/tex; mode=display">afactor\to \textbf{id}|\textbf{nat}|(aexpr)</script><script type="math/tex; mode=display">bexpr\to true|false|aexpr=aexpr|aexpr\le aexpr|\lnot bexpr|bexpr\&\&bexpr</script><p>其中，黑体字即为终止符号集合，起始符号即为stmts。</p><p>从任意一个非终结符号作用生成式多次后，我们可以得到一个由零个或多个终止符号构成的序列。零个终止符号的序列即空串可以用$\epsilon$表示。</p><p>从起始符号开始得到的终止符号序列即为合法的程序。语法分析所做的工作就是找到一个从起始状态出发得到待分析的程序的过程。如果找不到，则报告语法错误。</p><h3 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h3><p>语法分析树可以用图形的方式来描述上下文无关文法解析一个序列的过程。</p><p>给定一个上下文无关文法的解析过程，可以按照下面的方法构建语法分析树：</p><blockquote><ol><li><p>根节点标号为起始符号</p></li><li><p>每个叶子节点标号为一个终止符号或$\epsilon$</p></li><li><p>每个内部节点标号为一个非终止符号</p></li><li><p>每个标号为$A$的内部节点如果有从左到右标号依次为$X_1,X_2,\cdots,X_k$的儿子，那么有对应的推导规则$A\to X_1X_2\cdots X_k$</p></li></ol></blockquote><p>一个语法分析树的叶子节点从左到右构成了树的结果(yield)，即推导得到的符号串。</p><h3 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h3><p>在根据一个文法讨论某个符号串的结构时，我们可能会找到多个语法分析树生成同一个符号串。这样的文法称为有二义性(ambiguous)的。</p><p>例如，假设我们现在要定义一个仅由加减构成的运算式，如果我们使用如下定义：</p><script type="math/tex; mode=display">expr\to \textbf{id}|\textbf{nat}|expr+expr|expr-expr|(expr)</script><p>那么对于同一个符号串$9-5+2$，我们可以将其解析为$(9-5)+2$或$9-(5+2)$，这两种解析很显然是完全不同的。</p><p>使用一个更恰当的定义：</p><script type="math/tex; mode=display">expr \to factor|expr + factor|expr - factor</script><script type="math/tex; mode=display">factor\to \textbf{id}|\textbf{nat}|(expr)</script><p>可以消除这里的二义性。在这里，加减法是左结合的。</p><p>同样，对于右结合的运算符，我们也可以定义：</p><script type="math/tex; mode=display">right \to \textbf{id} = right|\textbf{id}</script><p>使用这个定义，我们可以得到没有二义性的形如$a=b=c$的连等号。</p><p>同时，我们还要考虑优先级的问题。在前面的IMP的例子中，我们已经看到了，我们可以将优先级较低的运算放在前面进行解析，保证解析的正确性。</p><h2 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h2><p>通过向产生式中加入一些规则，我们可以实现语法制导翻译。首先，我们构造语法分析树，按照需要构造属性依赖图，然后遍历语法树并按照语义规则进行计算。</p><p>属性(attribute)表示与程序构造相关的量。我们可以将属性扩展到文法符号上。</p><p>翻译方案(translation scheme)即是在语法树上遍历时的规则。</p><h3 id="综合属性"><a href="#综合属性" class="headerlink" title="综合属性"></a>综合属性</h3><p>如果一个语法分析树上各个节点标记了相应的属性值，那么这个语法分析书就称为注释语法分析树。</p><p>如果要求出语法树上某个属性时，只需要用到当前节点的符号和子节点的属性，那么称这个属性为综合属性(synthesized attribute)。如果只需要用到当前节点符号和父节点和兄弟节点，那么称这个属性为继承属性。</p><h3 id="语法制导定义"><a href="#语法制导定义" class="headerlink" title="语法制导定义"></a>语法制导定义</h3><p>把每个符号与一个属性集合进行关联，并把每个推导规则和一个语义规则进行关联。</p><p>例如，我们将在二义性一节中定义的没有二义性的表达式定义转为逆波兰表达式。</p><div class="table-container"><table><thead><tr><th style="text-align:center">推导规则</th><th style="text-align:center">语义规则</th></tr></thead><tbody><tr><td style="text-align:center">$expr\to factor$</td><td style="text-align:center">$expr.t=factor.t$</td></tr><tr><td style="text-align:center">$expr\to expr+factor$</td><td style="text-align:center">$expr.t=expr.t\mid\mid factor.t\mid\mid” + “$</td></tr><tr><td style="text-align:center">$expr\to expr-factor$</td><td style="text-align:center">$expr.t=expr.t\mid\mid factor.t\mid\mid” - “$</td></tr><tr><td style="text-align:center">$factor\to \textbf{id}$</td><td style="text-align:center">$factor.t=”\textbf{id}”$</td></tr><tr><td style="text-align:center">$factor\to \textbf{nat}$</td><td style="text-align:center">$factor.t=”\textbf{nat}”$</td></tr><tr><td style="text-align:center">$factor\to (expr)$</td><td style="text-align:center">$factor.t=expt.t$</td></tr></tbody></table></div><p>如果对于一个推导规则，只需要将其右边各个非终结符按照出现顺序排列并穿插一些附加串，则称为简单语法制导定义。</p><h3 id="翻译方案"><a href="#翻译方案" class="headerlink" title="翻译方案"></a>翻译方案</h3><p>在推导规则中加入一些程序片段，在解析时运行，即可形成翻译方案。这些程序片段被称为语义动作。</p><div class="table-container"><table><thead><tr><th style="text-align:center">推导规则</th><th style="text-align:center">语义动作</th></tr></thead><tbody><tr><td style="text-align:center">$expr\to factor$</td><td style="text-align:center">$expr\to factor$</td></tr><tr><td style="text-align:center">$expr\to expr+factor$</td><td style="text-align:center">$expr\to expr + factor\ \{print(+)\}$</td></tr><tr><td style="text-align:center">$expr\to expr-factor$</td><td style="text-align:center">$expr\to expr - factor\ \{print(-)\}$</td></tr><tr><td style="text-align:center">$factor\to \textbf{id}$</td><td style="text-align:center">$factor\to \textbf{id}\ \{print(\textbf{id})\}$</td></tr><tr><td style="text-align:center">$factor\to \textbf{nat}$</td><td style="text-align:center">$factor\to \textbf{nat}\ \{print(\textbf{nat})\}$</td></tr><tr><td style="text-align:center">$factor\to (expr)$</td><td style="text-align:center">$factor\to expr$</td></tr></tbody></table></div><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>语法分析是决定如何使用一个文法生成一个终结符号串的过程。</p><p>大多数语法分析可以分为自顶向下和自底向上两类。自顶向下可以手动实现一个高效的语法分析器，而自底向上可以处理更多种文法和翻译方案。</p><p>最朴素的方法就是直接进行回溯搜索，这种方法非常易于实现，但是效率可能比较差。</p><p>递归下降分析方法是一种自顶向下分析方法，使用一组递归过程处理输入。每个非终结符都有对应的过程。</p><p>其中一种比较简单的形式称为预测分析法。我们将由$\alpha$生成的产生式体的第一个元素集合记为$FIRST(\alpha)$</p><p>如果不同的生成式的$FIRST$集合互不相交，那么可以使用预测分析法。</p><p>直接使用预测分析法时，如果推导规则中有左递归，即产生式体最左边符号与产生式头相同，则可能会无限递归。这时要对原来的推导规则做一定的变化。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 上下文无关文法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-Aho-1</title>
      <link href="/2022/06/30/compilers_principles_aho_1/"/>
      <url>/2022/06/30/compilers_principles_aho_1/</url>
      
        <content type="html"><![CDATA[<p>编译器(compiler)就是将用一种语言编写的程序转化为等价的用目标语言编写的程序的一个程序。解释器(interpreter)是另一种常见的语言处理器，并不通过翻译的方式生成目标程序，而是直接利用用户提供的输入执行源程序中指定的操作。编译器生成的程序通常要比解释器快很多，但解释器的错误诊断效果通常比编译器更好。</p><p>一个源程序可能被分割为多个部分，并存放在独立的文件中。把源程序聚合在一起的任务由预处理器(preprocessor)独立完成。</p><p>将经过预处理器处理的程序作为输入传递给一个编译器，一般由编译器转为一个汇编语言程序作为输出，并由汇编器(assembler)处理生成可重定位的机器代码。</p><p>在大型的程序中，可重定位的机器代码通常要和其他的可重定位目标文件以及库文件连接在一起，形成真正运行的代码。外部内存地址的问题由链接器(linker)解决，最后加载器(loader)把所有可执行文件放到内存中执行。</p><h2 id="编译器的结构"><a href="#编译器的结构" class="headerlink" title="编译器的结构"></a>编译器的结构</h2><p>编译器将源程序映射为语义上等价的目标程序。映射的过程分为两个方面：分析(analysis)和综合(synthesis)。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>通常来说，编译的第一个步骤称为词法分析(lexical analysis)或扫描(scanning)。词法分析器读入源程序，将它们组成为有意义的词素(lexeme)序列。每个词素由一个词法单元(token)<code>&lt;token-name, attribute-value&gt;</code>构成。token-name是下一个步骤中要用到的符号，attribute-value是与符号表相关的信息。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>编译的第二个步骤称为语法分析(syntax analysis)或解析(parsing)。语法分析器利用词法分析器得到的词法单元的第一个分量创建树形的中间表示，如语法树(syntax tree)。给出了词法分析器产生的词法单元流的语法结构。</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语义分析器(semantic analysis)使用语法树和符号表中的信息来检查程序是否和语言定义的语义一致，并将这些信息存放在语法树或符号表中。同时收集类型信息，进行类型检查(type checking)。</p><h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>在语法分析和语义分析完成后，编译器一般会生成一个明确的低级的或类机器语言的中间表示。可以将这个中间表示看作在一个虚拟的机器上执行的程序。这个中间表示一般要满足易于生成并能较为轻松地翻译为目标语言。</p><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>机器无关的代码优化通过改进中间代码，以期望生成更好的目标代码。此外还有机器相关的优化。</p><p>代码优化必须满足下面的设计目标：</p><ol><li><p>优化必须是正确的，不能改变被编译程序的含义。</p></li><li><p>优化必须能够改善很多程序的性能。</p></li><li><p>优化需要的时间必须保持在合理的区间内。</p></li><li><p>所需要的工程方面的工作必须是可管理的。</p></li></ol><h3 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h3><p>代码生成器以中间形式作为输入，映射到目标语言。如果目标语言是机器语言，那么就要为每个变量选择寄存器或内存地址。代码生成的一个至关重要的方面是合理分配寄存器以存放变量的值。</p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>编译器在编译的过程中要记录源程序中使用的变量和过程的各种属性。这些由符号表来完成。</p><p>以上中的若干个步骤进行组合称为一趟(pass)。</p><h2 id="程序设计语言"><a href="#程序设计语言" class="headerlink" title="程序设计语言"></a>程序设计语言</h2><p>分类方式：</p><p>按代际来划分：第一代：机器语言；第二代：汇编语言；第三代：Fortran,Cobol,Lisp,C,C++,Java等高级语言；第四代是为特定应用设计的语言如用于生成报告的NOMAD，用于数据库查询的SQL等；第五代指基于逻辑和约束的语言，如Prolog和OPS5。</p><p>将程序中指明如何完成一个计算任务的语言称为强制式(imperative)语言，如C,C++,Java等；将程序中指明要进行哪些计算任务的语言称为声明式(declarative)语言，如Haskell,Prolog等。</p><p>冯·诺依曼语言(von Neumann language)是指以冯·诺伊曼计算机体系结构为计算模型的语言。</p><p>面向对象语言(object-oriented language)指的是支持面向对象编程的语言。</p><p>脚本语言(scripting language)是具有高层次运算符的解释型语言。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语义学简介</title>
      <link href="/2022/06/29/formal_semantics/"/>
      <url>/2022/06/29/formal_semantics/</url>
      
        <content type="html"><![CDATA[<p>如果要描述一个语言，我们需要描述三个方面的内容：字符集(alphabet)、语法(syntax)、语义(semantics)。对于一个程序设计语言来说也是如此。</p><p>语言的语法决定了我们能够写出来怎样的程序，而语义则决定了不同程序执行的具体的效果。</p><p>在写程序的时候，我们往往比较关注语言的语法，以写出能够被接受的程序。但同时，语言的语义也相当重要。有了恰当定义的语义，我们才能对程序运行的行为进行准确的描述，给定解释程序的标准，同时这也是进行程序分析的基础。</p><p>实际上，说明一个程序的正确性要比写出这个程序困难的多，一个正确定义的语义是保证程序正确性的重要条件。</p><h3 id="内存-State"><a href="#内存-State" class="headerlink" title="内存(State)"></a>内存(State)</h3><p>程序在运行的时候，必然要涉及内存的状态，及变量的值等。要描述程序运行的行为，就必须要对计算机的内存状态给出定义。</p><p>我们将内存抽象为一个从变量到值的映射，定义为一个状态(State)，如$(x\mapsto a;y\mapsto b;z\mapsto c)$。状态会随着程序的运行而发生变化。而语义就是描述了一个程序将一个状态转移到了另一个状态。</p><p>下面考虑一个简单的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z := x;</span><br><span class="line">x := y;</span><br><span class="line">y := z;</span><br></pre></td></tr></table></figure><h3 id="操作语义-Operational-Semantics"><a href="#操作语义-Operational-Semantics" class="headerlink" title="操作语义(Operational Semantics)"></a>操作语义(Operational Semantics)</h3><p>操作语义将一个程序执行的行为解释为初始状态经过一个程序后得到一个最终状态。</p><p>比如在$st=(x\mapsto a;y\mapsto b;z\mapsto c)$上运行程序<code>z := x; x := y; y := z</code>。</p><p>这里我们会用到两条推导规则：</p><script type="math/tex; mode=display">\begin{array}{c}    st\ a = n\\\hline    st =[x := a]\Rightarrow (x\mapsto n; st)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    st =[c_1]\Rightarrow st'\ \ \ st' =[c_2]\Rightarrow st''\\\hline    st =[c_1;c_2]\Rightarrow st''\end{array}</script><p>有了这两条推导规则，我们可以得到，</p><script type="math/tex; mode=display">\begin{array}{c}    (x\mapsto a;y\mapsto b;z\mapsto c)\ x = a\\\hline    (x\mapsto a;y\mapsto b;z\mapsto c) =[z := x]\Rightarrow (x\mapsto a;y\mapsto b;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    (x\mapsto a;y\mapsto b;z\mapsto c)\ y = b\\\hline    (x\mapsto a;y\mapsto b;z\mapsto a) =[x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}        (x\mapsto a;y\mapsto b;z\mapsto c) =[z := x]\Rightarrow (x\mapsto a;y\mapsto b;z\mapsto a)\\        (x\mapsto a;y\mapsto b;z\mapsto a) =[x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)    \\\hline    (x\mapsto a;y\mapsto b;z\mapsto c) =[z := x; x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}        (x\mapsto b;y\mapsto b;z\mapsto a)\ z = a    \\\hline    (x\mapsto b;y\mapsto b;z\mapsto a) =[y := z]\Rightarrow (x\mapsto b;y\mapsto a;z\mapsto a)\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}(x\mapsto a;y\mapsto b;z\mapsto c) =[z := x; x := y]\Rightarrow (x\mapsto b;y\mapsto b;z\mapsto a)\\    (x\mapsto b;y\mapsto b;z\mapsto a) =[y := z]\Rightarrow (x\mapsto b;y\mapsto a;z\mapsto a)\\\hline(x\mapsto a;y\mapsto b;z\mapsto c) =[z := x; x := y; y := z]\Rightarrow  (x\mapsto b;y\mapsto a;z\mapsto a)\end{array}</script><p>证明了程序的正确性。</p><h3 id="指称语义-Denotational-Semantics"><a href="#指称语义-Denotational-Semantics" class="headerlink" title="指称语义(Denotational Semantics)"></a>指称语义(Denotational Semantics)</h3><p>指称语义将程序抽象为一个数学上的函数。比如，要描述程序对状态的影响，我们可以把程序看作$State\to State$的函数。</p><p>比如在$st=(x\mapsto a;y\mapsto b;z\mapsto c)$上运行程序<code>z := x; x := y; y := z</code>。</p><p>这里我们会用到两条推导规则：</p><script type="math/tex; mode=display">[\![ s_1; s_2 ]\!] = [\![ s_2 ]\!]\circ [\![s_1]\!]</script><script type="math/tex; mode=display">([\![ x := v]\!]\ st)\ y = \left\{\begin{array}{ll}st\ y& ,y\not =x\\v& ,otherwise\end{array}\right.</script><p>由此，我们可以得到，</p><script type="math/tex; mode=display">\begin{array}{rcl}    [\![z := x; x := y; y := z]\!](x\mapsto a;y\mapsto b;z\mapsto c)&=&\\    [\![ y := z]\!]\circ [\![x := y]\!]\circ[\![z := x]\!](x\mapsto a;y\mapsto b;z\mapsto c)&=&\\    [\![ y := z]\!]\circ [\![x := y]\!](x\mapsto a;y\mapsto b;z\mapsto a)&=&\\    [\![ y := z]\!](x\mapsto b;y\mapsto b;z\mapsto a)&=&(x\mapsto b;y\mapsto a;z\mapsto a)\\\end{array}</script><p>不难发现，操作语义和指称语义的原理是几乎相同的，区别只在于描述不同。</p><h3 id="公理语义-Axiomatic-Semantics"><a href="#公理语义-Axiomatic-Semantics" class="headerlink" title="公理语义(Axiomatic Semantics)"></a>公理语义(Axiomatic Semantics)</h3><p>公理语义更关注程序的性质，通过一系列的公理推出程序在某些状态上符合的某个定理。</p><p>如一个最著名的实例，霍尔逻辑(Hoare Logic)。霍尔逻辑由霍尔三元组来描述，其由三个部分即前条件(pre-condition)、程序和后条件(post-condition)组成。其含义为程序在满足前条件的状态上运行得到的状态满足后条件。如$\{P\}c\{Q\}$</p><p>比如在$st=(x\mapsto a;y\mapsto b;z\mapsto c)$上运行程序<code>z := x; x := y; y := z</code>。</p><p>这里我们会用到两条推导规则：</p><script type="math/tex; mode=display">\begin{array}{c}    \{P\}c_1\{Q\}\ \ \ \{Q\}c_2\{R\}\\\hline    \{P\}c_1;c_2\{R\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{P[a/x]\}x:=a\{R\}\end{array}</script><p>其中$P[a/x]$指使用a替换P中的所有x，如$\{Y = 2\} X := Y \{X = 2\}$</p><p>通过上面两条规则，我们可以得到</p><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{x=a\land y=b\}z := x\{y=b\land z=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{y=b\land z=a\}x := y\{x=b\land z=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \{x=a\land y=b\}z := x\{y=b\land z=a\}\ \ \ \{y=b\land z=a\}x := y\{x=b\land z=a\}\\\hline    \{x=a\land y=b\}z := x; x := y\{x=b\land z=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \\\hline    \{x=b\land z=a\}y := z\{x=b\land y=a\}\end{array}</script><script type="math/tex; mode=display">\begin{array}{c}    \{x=a\land y=b\}z := x; x := y\{x=b\land z=a\}\ \ \ \{x=b\land z=a\}y := z\{x=b\land y=a\}\\\hline    \{x=a\land y=b\}z := x; x := y; y := z\{x=b\land y=a\}\end{array}</script><p>证明了程序关于交换的一个性质。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 形式语义 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
